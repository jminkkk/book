# 자바와 객체 지향

## 객체 지향은 인간 지향이다
객체 지향은 '우리가 눈으로 보고, 느끼고, 생활하는 현실 세계처럼 프로그래밍할 수는 없을까'라는 고민 속에서 탄생

객체 지향은 직관적이다.
+ 객체 지향을 이해하기 위해 일단 큰 그림을 생각하자
    + 세상에 존재하는 모든 것은 사물, 즉 객체이다.
    + 각각의 사물은 고유하다.
    + 사물은 속성을 갖는다.
    + 사물은 행위를 한다.
## 객체 지향의 4대 특성 - 캡! 상추다
객체 지향의 4대 특성인 캡상추다
+ 캡슐화
    + 정보 은닉
+ 상속
    + 재사용
+ 추상화
    + 모델링
+ 다형성
    + 사용 편의

## 클래스 vs 객체 = 붕어빵틀 vs 붕어빵??
클래스와 객체의 관계은 붕어빵틀과 붕어빵이 아니다.

붕어빵틀이 붕어빵을 찍어내서 클래스라고 한다면 금형 기계는 붕어빵 틀을 찍어내는 클래스가 된다.
+ 금형기계 붕어빵틀 = new 금형기계();
위 코드를 인간적인 말로 번역해보면,
+ 새로운 금형기계를 하나 만들었더니 붕어빵틀이 되었다?

나아가 다음 문제들의 답을 생각해보자
+ 사람은 클래스인가? 객체인가?
+ 김연아은 클래스인가? 객체인가?
+ 뽀로로는 클래스인가? 객체인가?
+ 펭귄은 클래스인가? 객체인가?

클래스와 객체를 구분하는 간단한 방법은 나이를 물어보는 것이다.
+ 사람의 나이는 몇살?
+ 김연아의 나이는 몇살?
+ 뽀로로의 나이는 몇살?
+ 펭귄의 나이는 몇살?

#### 클래스는 분류에 대한 개념이지 실체가 아니다. 객체는 실체다.
그럼 이제 붕어빵틀과 붕어빵이라는 잘못된 메타포 대신 필자가 올바른 메타포를 제시하겠다.
클래스 : 객체 = 펭귄 : 뽀로로 = 사람 : 김연아

# 1. 추상화: 모델링
추상화라고 하면 무엇이 떠오르는가?

입체파 화가 피카소로 인해 알려진 추상화는 Abstract Painting이다.

같은 Abstract이다. 그렇다면 추상화 그림의 특징?
+ 피카소는 극사실주의와 같이 눈에 보이는 그대로의 사물(객체)를 그린 것이 아닌, 마음 속에 느껴지는 그 사람의 특징을 그렸다.
    + 마음 속에 느껴지는 그 사람의 특징을 극대화해서 추상화로 그렸다.
+ 이집트 화가들은 그 사람의 사실적인 모습이 아니라 각 부분의 특징을 가장 잘 표현할 수 있도록 신체를 분해/결합하여 벽화를 그렸다.
    + 실제 모습이 아닌 추상적인 모습을 그려 오히려 그 특징을 정확하게 묘사하려 했다.

추상의 사전적 의미는 무엇일까?
#### 추상 : 여러가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용

## 추상화는 모델링이다.
추상화는 구체적인 것을 분해해서 관찰자가 관심있는 특성만 가지고 재조합을 하는 것이라고 정리 가능하다.

object를 번역했을 때, 객체보다는 개체라는 뜻이 더 맞다.

#### 따라서 객체란: 세상에 존재하는 유일무이한 사물
+ 클래스는 같은 특성을 지닌 여러 객체를 총칭하는 집합의 개념

### 컨텍스트
+ 내가 창조하려는 세상은 어떤 세상인가? 
+ 좀 더 프로그래밍적으로 질문을 바꾼다면, "내가 만들고자 하는 애플리케이션은 어디에서 사용될 것인가?"
+ 만약 병원 어플리케이션을 만들고 있다면 사람은 환자를 의미하는 좀 더 구체적인 이름으로 바꿀 수 있고 클래스 설계도도 달라진다.

모델은 실제 사물을 정확히 복제하는 게 아니라 목적에 맞게 **관심 있는 특성만을 추출해서 표현하는 것**

#### 따라서 객체 지향에서 추상화의 결과는 클래스다.

## 추상화와 T메모리
+ 애플리케이션의 경계 설정하기
+ 클래스 설계를 위해 해당 클래스의 객체로부터 공통 특성을 뽑아내기
    + 클래스 설계에서 제일 중요한 것은 **추상화**

#### Mouse mickey = new Mouse()
+ 한 마리 쥐가 태어났으니 그 이름을 mickey라 하였음
+ 쥐 : 클래스
+ 한 마리의 쥐 : 클래스의 인스턴스 = 객체
+ mickey : **객체 참조 변수**


## 클래스 멤버 vs 객체 멤버 = static 멤버 vs 인스턴스 멤버
+ 클래스 멤버 = static 멤버 = 정적 멤버
+ 객체 멤버 = 인스턴스 멤버
![image](https://github.com/jminkkk/TIL/assets/102847513/88c0ca45-33c4-429e-8d14-05b7c2c7ddff)

# 2. 상속: 재사용 + 확장
객체 지향에서의 상속은 상위 클래스의 특성을 하위 클래스에서 상속(특성 상속)하고 거기에 더해 필요한 특성을 추가, 

**즉 확장해서 사용할 수 있다는 것**
+ 따라서 부모-자식 클래스라는 표현보다는 상위-하위 클래스, 또는 슈퍼-서브 클래스라고 표현
    + 또한 상속의 개념이 조직도나 계층도가 아닌 **분류도**라는 사실을 염두하자!
+ 상위 클래스 쪽으로 갈수록 추상화, 일반화됐다고 말하며
+ 하위 클래스 쪽으로 갈수록 구체화, 특수화됐다고 함
#### 하위 클래스나 상위 클래스다.

```
아버지 영희아빠 = new 딸():
// 딸을 낳으니 아버지 역할을 하는 영희 아빠라 이름 지었다???
```
+ 이상하다.
+ 자바 언어에서 inheritance(상속)라는 키워드는 존재하지 않음
    + 대신 **extends(확장)가 존재함**
#### 따라서 객체 지향의 상속은 inheritance가 아닌 extends이다.
## 상속의 강력함
아래의 코드를 보면, 다시 한번 **하위 클래스는 상위 클래스**다.
```java
public class Driver93 {
    public static void main(String[] args) {
        동물[] animals = new동물[7]:
        
        animals[0] = new 동물(); 
        animals[1] = new 포유류();
        animals[2] = new 조류();
        animals[3] = new 고래(); 
        animals[4] = new 박쥐(); 
        animals[5]= new 참새(); 
        animals[6]= new 펭귄();

        for (int index = 0; index < animals.length; index++) { 
            animals[index].showMe();
        }
    }
}
```

## 상속은 is a 관계를 만족해야 한다?
상속에 대한 또 한가지의 오해: 상속은 is a 관계를 만족해야 함

+ 펭귄 is a 동물
+ 펭귄은 한 마리 동물이다.
    + 그렇다면 한 마리 동물은 클래스일까?

is a 관계를 완벽하게 번역하면 '하위 클래스는 하나의 상위 클래스이다??' 
+ 상위 클래스는 분류/집단이지만 그러나 하나의 상위 클래스는 하나의 객체이다.

#### 따라서 상속 관계의 더 명확한 영어 표현은 is a kind of 관계이다.
+ 하위 클래스 is a kind of 상위 클래스
+ 펭권 is a kind of 조류
    + 펭권은 조류의 한 분류다.

### 따라서 상속에서 아래의 3문장을 기억하자
+ 객체 지향의 상속은 **상위 클래스의 특성을 재사용**하는 것이다. 
+ 객체 지향의 상속은 **상위 클래스의 특성을 확장**하는 것이다.
+ 객체 지향의 상속은 **is a kind of 관계를 만족**해야 한다.

## 다중 상속과 자바
자바는 왜 다중 상속을 지원하지 않는가?
+ 인어공주 예시 속 인어는 사람과 물고기를 상속한다고 해보자
+ 사람도 수영할수있고. 물고기도 수영할수있는데 
    + 인어에게 "수영해!"라고 한다면 사람처럼 말과 다리를 저어 수영?
    + 아니면 물고기처럼 가슴,등, 꼬리 지느러미로 헤엄?

#### 이와 같은 문제를 다중 상속의 **다이아몬드 문제**

다중 상속은 득보단 실이 많기 때문에 자바는 다중 상속을 포기했다.

## 상속과 인터페이스
다중 상속을 포기하고 인터페이스를 도입한 자바에서 인터페이스는 어떤 관계를 나타낼까?
+ 인터페이스는 be able to 즉, '무엇을 할 수 있는' 이라는 형태로 만드는 것이 좋다
+ 자바 API에서도 이러한 형식의 인터페이스 예시가 존재하는데 
    + Serializable 인터페이스 : 직렬화할 수 있는
    + Cloneable 인터페이스 : 복제할 수 있는   
    + Comparable 인터페이스 : 비교할 수 있는   
    + Runnable 인터페이스 : 실행할 수 있는   

이때 상위 클래스는 하위 클래스에게 특성(속성과 메서드)를 상속해주고, 인터페이스는 클래스가 무엇을 할 수 있다고 하는 기능을 **구현하도록 강제**한다

그렇다면, 
+ 상위 클래스는 하위 클래스에게 물려줄 특성이 많을수록 좋을까? 적을수록 좋을까?
+ 인터페이스는 구현을 강제할 메서드가 많을수록 좋을까? 적을수록 좋을까?

####  상위 클래스는 물려줄 특성이 풍성 할수록 좋고(LSP: 리스코프 치환), 
#### 인터페이스는 구현을 강제할 메서드의 개수가 적을수록 좋다(ISP: 인터페이스 분할).

## 상속과 T메모리
```java
public class Driver {

public static void main(String[] args) { 
    Penguin pororo = new Penguin(); // 5
    
    pororo. name = "뽀로로";
    pororo.habitat = "남극"; 
    
    pororo.showName();
    pororo.showlabitat();

    Animal ping = new Penguin(); // 13

    pingu.name = "핑구" ;
    // pingu. habitat = "EBS";

    pingu. showName ();
    // pingu.showHabitat();

    // Penguin happyfeet = new Animal();
```

5번째 줄을 실행한 뒤의 T 메모리는
<img src = https://github.com/JNU-econovation/jnu-wiki-be/assets/102847513/d3f9ecc4-d00c-41db-83ab-4da1348b3456 width = 70%>

#### 여기서 중요한 것은 Penguin 클래스의 인스턴스만 힙 영역에 생긴 것이 아니라, Animal 클래스의 인스턴스도 함께 힙 영역에 생성된다.

13번째 줄을 실행한 뒤의 T 메모리는
<img src = https://github.com/jminkkk/TIL/assets/102847513/6f7b27ed-245b-47c0-a393-aa6b566e974a width = 70%>
 
# 3. 다형성: 사용편의성
객체 지향에서 다형성이라고 하면 **오버라이딩**과 **오버로딩**이라고 할 수 있다.
### 오버라이딩? 오버로딩?
+ 오버라이딩: 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 재정의
+ 오버로딩: 같은 메서드 이름, 다른 인자 목록으로 상위 클래스의 메서드를 재정의

## 다형성과 T메모리
```java
public class Driver {

public static void main(String[] args) { 
    Penguin pororo = new Penguin(); // 5
    
    pororo. name = "뽀로로";
    pororo.habitat = "남극"; 
    
    pororo.showName();
    pororo.showName("초보람보");
    pororo.showlabitat();

    Animal pingu = new Penguin(); // 14

    pingu.name = "핑구" ;
    pingu. showName ();
```
14번째 줄을 실행한 후의 T 메모리는 다음과 같다.
<img width="527" alt="스크린샷" src="https://github.com/jminkkk/TIL/assets/102847513/f9367938-14d7-48c3-9c46-408a7041ce00">

+ 여기서 주목할 것은 pingu 객체 참조 변수는 타입이 Animal타입이라는 것이다.
+ 그럼에도 Animal객체의 showName()은 Penguin 객체의 showName()에 의해 가려져 있다.

# 4. 캡슐화: 정보은닉
접근 제어자는 아래의 그림처럼 단순하지 않다.

<img width="305" alt="스크린샷" src="https://github.com/jminkkk/TIL/assets/102847513/d098dc8b-ccde-49e9-98c8-912980907c3f">

+ 특히 객체 멤버에 대한 접근인가, 정적 멤버에 대한 접근인가에 따라 생각할 것이 많아진다.
+ 그리고 protected가 자신과 상속 관계에 있는 서브 클래스만 접근가능한 것이 아니라 **같은 패키지라면 한 집에 산다고 생각하기에 접근 가능하다는 사실**도 알아야 함

#### 상속 받지 않았다면 객체 멤버는 객체를 생성한 후 객체 참조 변수를 이용해 접근해야 함
#### 정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장
+ 그 이유는 사람.인구, 고양이.다리개수 형식으로 접근하는 것이 홍길동.인구수, 키티. 다리개수 형식으로 접근하는것보다 권장됨

## 참조 변수의 복사
기본 자료형 변수를 복사하는 경우 
+ Call By Value(값에 의한 호출)에 의해 그 값이 복사되며 두 변수는 서로에게 영향 X
객체 참조 변수를 복사하는 경우
+ Call ByReference에 의해 참조 변수를 복사하든 결국은 변수가 가진 값이 그대로 복사된다는것

즉, 기억해야 할 부분은 아래와 같다.
+ 기본 자료형 변수는 값을 값 자체로 판단
+ 참조 자료형 변수는 값을 주소, 즉 포인터로 판단
+ 기본 자료형 변수를 복사할 때, 참조 자료형 변수를 복사할 때 일어나는 일은 같다.
    + 즉, 가지고 있는 값을 그대로 복사해서 넘겨준다.